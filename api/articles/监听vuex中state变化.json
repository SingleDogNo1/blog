{"title":"监听vuex中state变化","slug":"监听vuex中state变化","date":"2021-03-09T06:46:08.000Z","updated":"2023-06-21T08:55:09.216Z","comments":true,"path":"api/articles/监听vuex中state变化.json","excerpt":null,"covers":["/img/vuex-state-1.png","/img/vuex-state-2.png","/img/vuex-state-3.png"],"content":"<p>书说简短,直接开整.需求是这样的: 点击变更联系人按钮,跳转到选人列表,点击人员,回到前一页,触发更换联系人功能.</p>\n<ul>\n<li>点击更改按钮<br><img src=\"/img/vuex-state-1.png\" alt=\"点击按钮\"></li>\n<li>选择具体成员<br><img src=\"/img/vuex-state-2.png\" alt=\"选择人员\"></li>\n<li>触发更改操作<br><img src=\"/img/vuex-state-3.png\" alt=\" 执行操作\"></li>\n</ul>\n<p>因为涉及到路由跳转,所以我的实现方法是,第二步中选择的人员信息保存在了 vuex 里,因此整个过程遇到的难点如下:</p>\n<ul>\n<li>vuex 中 state 的值怎么监听到变化?</li>\n</ul>\n<p>vuex 中的数据监听有两种方式,一种可以放在 <code>watch</code>中直接监听</p>\n<div class=\"code-panel__wrapper\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"><header class=\"mac-panel\"><span class=\"doc-path\"></span><span class=\"mac-panel__language\">JAVASCRIPT</span></header><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    watch: &#123;</span><br><span class=\"line\">      <span class=\"string\">'$store.state.user'</span>(val) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></div>\n<p>但在本业务中,比较新旧联系人是否是同一个,以及文案的拼接,都逻辑依赖接口返回的数据信息,单号<code>PC20210308002</code>和原有联系人<code>admin1</code>是需要等接口返回值的,这样的话就不能写在 <code>watch</code>里,所以使用了第二种方法:<a href=\"https://vuex.vuejs.org/zh/api/#watch\" target=\"_blank\" rel=\"noopener\">使用 vuex 自带的 watch 功能</a></p>\n<div class=\"code-panel__wrapper\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"><header class=\"mac-panel\"><span class=\"doc-path\"></span><span class=\"mac-panel__language\">JAVASCRIPT</span></header><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEST_API().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回需要的信息 res...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$store.watch(</span><br><span class=\"line\">    state =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.user</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    value =&gt; &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 变化的值 value</span></span><br><span class=\"line\">      <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 类似 vue 的 watch 参数,如果有需要的话</span></span><br><span class=\"line\">      deep: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      immediate: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n<p>这样可以保证触发的逻辑是在数据渲染后,但是任然存在问题: <strong>watch方法会随着路由的 history 多次触发,现象类似于 EventBus 的触发</strong>. 其实文档有提到, 该<code>watch</code>方法会返回一个 function,调用此方法即可停止监听,所以只要再稍加修改:</p>\n<div class=\"code-panel__wrapper\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"><header class=\"mac-panel\"><span class=\"doc-path\"></span><span class=\"mac-panel__language\">JAVASCRIPT</span></header><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">  TEST_API().then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.eventHub = <span class=\"keyword\">this</span>.$store(<span class=\"comment\">/* ... */</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.eventHub()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>其实还是 eventBus 的思想啦…</p>\n","more":"<p>书说简短,直接开整.需求是这样的: 点击变更联系人按钮,跳转到选人列表,点击人员,回到前一页,触发更换联系人功能.</p>\n<ul>\n<li>点击更改按钮<br><img src=\"/img/vuex-state-1.png\" alt=\"点击按钮\"></li>\n<li>选择具体成员<br><img src=\"/img/vuex-state-2.png\" alt=\"选择人员\"></li>\n<li>触发更改操作<br><img src=\"/img/vuex-state-3.png\" alt=\" 执行操作\"></li>\n</ul>\n<p>因为涉及到路由跳转,所以我的实现方法是,第二步中选择的人员信息保存在了 vuex 里,因此整个过程遇到的难点如下:</p>\n<ul>\n<li>vuex 中 state 的值怎么监听到变化?</li>\n</ul>\n<p>vuex 中的数据监听有两种方式,一种可以放在 <code>watch</code>中直接监听</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    watch: &#123;</span><br><span class=\"line\">      <span class=\"string\">'$store.state.user'</span>(val) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但在本业务中,比较新旧联系人是否是同一个,以及文案的拼接,都逻辑依赖接口返回的数据信息,单号<code>PC20210308002</code>和原有联系人<code>admin1</code>是需要等接口返回值的,这样的话就不能写在 <code>watch</code>里,所以使用了第二种方法:<a href=\"https://vuex.vuejs.org/zh/api/#watch\" target=\"_blank\" rel=\"noopener\">使用 vuex 自带的 watch 功能</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEST_API().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回需要的信息 res...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$store.watch(</span><br><span class=\"line\">    state =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.user</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    value =&gt; &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 变化的值 value</span></span><br><span class=\"line\">      <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 类似 vue 的 watch 参数,如果有需要的话</span></span><br><span class=\"line\">      deep: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      immediate: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样可以保证触发的逻辑是在数据渲染后,但是任然存在问题: <strong>watch方法会随着路由的 history 多次触发,现象类似于 EventBus 的触发</strong>. 其实文档有提到, 该<code>watch</code>方法会返回一个 function,调用此方法即可停止监听,所以只要再稍加修改:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">  TEST_API().then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.eventHub = <span class=\"keyword\">this</span>.$store(<span class=\"comment\">/* ... */</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.eventHub()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实还是 eventBus 的思想啦…</p>\n","categories":[{"name":"vue","path":"api/categories/vue.json"},{"name":"vuex","path":"api/categories/vuex.json"}],"tags":[{"name":"vue","path":"api/tags/vue.json"},{"name":"vuex","path":"api/tags/vuex.json"}]}